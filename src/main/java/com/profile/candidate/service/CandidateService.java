package com.profile.candidate.service;

import com.profile.candidate.dto.CandidateDto;
import com.profile.candidate.dto.CandidateGetResponseDto;
import com.profile.candidate.dto.CandidateResponseDto;
import com.profile.candidate.exceptions.CandidateAlreadyExistsException;
import com.profile.candidate.exceptions.CandidateNotFoundException;
import com.profile.candidate.model.CandidateDetails;
import com.profile.candidate.repository.CandidateRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class CandidateService {

    @Autowired
    private CandidateRepository candidateRepository;

    public CandidateResponseDto submitCandidate(CandidateDto candidateDto) {
        // Step 1: Validate input fields
        validateCandidateDetails(candidateDto);

        // Step 2: Check for duplicates
        checkForDuplicates(candidateDto);

        // Step 3: Convert CandidateDto to CandidateDetails (Entity)
        CandidateDetails candidateDetails = convertToEntity(candidateDto);

        // Step 4: Save the candidate details to the database
        CandidateDetails savedCandidate = candidateRepository.save(candidateDetails);

        // Step 5: Create and return the response DTO
        return new CandidateResponseDto(
                "Candidate profile submitted successfully.",
                savedCandidate.getCandidateId(),
                savedCandidate.getUserId(),
                savedCandidate.getJobId()
        );
    }

    private CandidateDetails convertToEntity(CandidateDto candidateDto) {
        // Convert CandidateDto to CandidateDetails (Entity)
        CandidateDetails candidateDetails = new CandidateDetails();

        candidateDetails.setJobId(candidateDto.getJobId());  // Ensure jobId is set here
        candidateDetails.setUserId(candidateDto.getUserId());
        candidateDetails.setFullName(candidateDto.getFullName());
        candidateDetails.setEmailId(candidateDto.getEmailId());
        candidateDetails.setContactNumber(candidateDto.getContactNumber());
        candidateDetails.setCurrentOrganization(candidateDto.getCurrentOrganization());
        candidateDetails.setQualification(candidateDto.getQualification());
        candidateDetails.setTotalExperience(candidateDto.getTotalExperience());
        candidateDetails.setRelevantExperience(candidateDto.getRelevantExperience());
        candidateDetails.setCurrentCTC(candidateDto.getCurrentCTC());
        candidateDetails.setExpectedCTC(candidateDto.getExpectedCTC());
        candidateDetails.setNoticePeriod(candidateDto.getNoticePeriod());
        candidateDetails.setCurrentLocation(candidateDto.getCurrentLocation());
        candidateDetails.setPreferredLocation(candidateDto.getPreferredLocation());
        candidateDetails.setSkills(candidateDto.getSkills());
        candidateDetails.setCommunicationSkills(candidateDto.getCommunicationSkills());
        candidateDetails.setRequiredTechnologiesRating(candidateDto.getRequiredTechnologiesRating());
        candidateDetails.setOverallFeedback(candidateDto.getOverallFeedback());

        // Set the profile received date (auto-generated by prePersist)
        candidateDetails.setProfileReceivedDate(LocalDate.now());

        return candidateDetails;
    }


    private void validateCandidateDetails(CandidateDto candidateDetails) {
        if (candidateDetails.getFullName() == null || candidateDetails.getFullName().trim().isEmpty()) {
            throw new CandidateAlreadyExistsException("Full Name is required and cannot be empty.");
        }

        if (candidateDetails.getEmailId() == null || !candidateDetails.getEmailId().matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
            throw new CandidateAlreadyExistsException("Invalid email format.");
        }

        if (candidateDetails.getContactNumber() == null || !candidateDetails.getContactNumber().matches("\\d{10}")) {
            throw new CandidateAlreadyExistsException("Contact number must be 10 digits.");
        }
    }

    private void checkForDuplicates(CandidateDto candidateDetails) {
        // Check for duplicate Full Name
        Optional<CandidateDetails> existingFullName = candidateRepository.findByFullName(candidateDetails.getFullName());
        if (existingFullName.isPresent()) {
            throw new CandidateAlreadyExistsException("Candidate with the same full name already exists: " + existingFullName.get().getFullName());
        }

        // Check for duplicate Email ID
        Optional<CandidateDetails> existingEmailId = candidateRepository.findByEmailId(candidateDetails.getEmailId());
        if (existingEmailId.isPresent()) {
            throw new CandidateAlreadyExistsException("Candidate with the same email ID already exists: " + existingEmailId.get().getEmailId());
        }

        // Check for duplicate Contact Number
        Optional<CandidateDetails> existingContactNumber = candidateRepository.findByContactNumber(candidateDetails.getContactNumber());
        if (existingContactNumber.isPresent()) {
            throw new CandidateAlreadyExistsException("Candidate with the same contact number already exists: " + existingContactNumber.get().getContactNumber());
        }
    }
    public List<CandidateDetails> getSubmissions() {
        // Retrieve all candidates from the repository
        return candidateRepository.findAll();
    }

    // Method to get candidate submissions by userId
    public List<CandidateGetResponseDto> getSubmissionsByUserId(String userId) {
        // Retrieve candidates by userId from the repository
        List<CandidateDetails> candidates = candidateRepository.findByUserId(userId);

        // If no candidates are found, throw a CandidateNotFoundException
        if (candidates.isEmpty()) {
            throw new CandidateNotFoundException("No submissions found for userId: " + userId);
        }

        // Map the list of CandidateDetails to List<CandidateGetResponseDto>
        List<CandidateGetResponseDto> candidateDtos = candidates.stream()
                .map(CandidateGetResponseDto::new)  // Convert each CandidateDetails to CandidateGetResponseDto
                .collect(Collectors.toList());

        // Return the list of CandidateGetResponseDto
        return candidateDtos;
    }

}